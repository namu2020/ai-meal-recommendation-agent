# 🎛️ 동적 워크플로우 시스템 가이드

## 📋 개요

기존 시스템은 모든 질문에 대해 고정된 순서로 모든 에이전트를 실행했습니다. 이로 인해:
- ❌ "된장찌개 만드는 법 알려줘" → 불필요하게 영양사, 예산 관리자 등 모두 실행
- ❌ 필요 없는 변수로 인한 에러 발생
- ❌ 느린 응답 속도

**새로운 동적 워크플로우 시스템**은 사용자 의도를 분석하여 필요한 에이전트만 선택적으로 실행합니다!

---

## 🏗️ 시스템 아키텍처

```
사용자 입력
    ↓
[1단계] 오케스트레이터 (의도 분석)
    ↓
[2단계] 워크플로우 결정
    ↓
[3단계] 필요한 에이전트만 실행
    ↓
결과 반환
```

---

## 🎯 핵심 컴포넌트

### 1. 에이전트 카드 시스템 (`agent_cards.py`)

각 에이전트의 역할과 사용 시나리오를 정의한 메타데이터 시스템입니다.

**구조:**
```python
AGENT_CARDS = {
    "agent_type": {
        "name": "에이전트 이름",
        "role": "역할",
        "capabilities": ["능력1", "능력2", ...],
        "use_cases": ["사용 시나리오1", ...],
        "keywords": ["키워드1", "키워드2", ...]
    }
}
```

**활용:**
- 오케스트레이터가 의도 분석 시 참고
- 적절한 에이전트 선택 기준
- 사용자에게 에이전트 정보 제공

### 2. 오케스트레이터 에이전트 (`agents/orchestrator_agent.py`)

사용자 의도를 분석하고 워크플로우를 결정하는 AI 지휘자입니다.

**도구:**
- `analyze_user_intent`: 사용자 메시지 분석 → 워크플로우 타입 반환
- `plan_workflow`: 실행 계획 수립

**출력 예시:**
```json
{
  "workflow_type": "RECIPE_ONLY",
  "required_agents": ["chef_agent"],
  "primary_agent": "chef_agent",
  "reasoning": "사용자가 조리법을 요청함",
  "user_intent": "된장찌개 레시피"
}
```

### 3. 의도 분석 도구 (`tools/orchestrator_tools.py`)

**`analyze_user_intent`**
- OpenAI GPT-4o-mini를 사용하여 의도 분석
- 대화 맥락 고려
- JSON 형식으로 워크플로우 정보 반환

**`plan_workflow`**
- 의도 분석 결과를 바탕으로 실행 계획 수립
- 태스크 순서 결정

### 4. 동적 워크플로우 매니저 (`crew.py`)

**핵심 메서드:**

#### `analyze_intent(user_request: str) -> dict`
사용자 요청을 분석하여 워크플로우 결정
- 대화 히스토리 참조
- 오케스트레이터 에이전트 실행
- JSON 파싱 및 검증

#### `create_dynamic_tasks(user_request: str, intent: dict) -> list[Task]`
워크플로우 타입에 따라 동적으로 태스크 생성
- `RECIPE_ONLY`: 요리사만 실행
- `BUDGET_CHECK`: 예산 관리자만
- `FULL_RECOMMENDATION`: 모든 에이전트

#### `run(user_request: str) -> str`
통합 실행 파이프라인
1. 의도 분석
2. 태스크 생성
3. 에이전트 선택
4. 실행 및 결과 반환

---

## 📊 워크플로우 타입

### 1. FULL_RECOMMENDATION (전체 메뉴 추천)
**트리거:** "오늘 저녁 메뉴 추천해줘", "점심 뭐 먹을까?"

**실행 에이전트:**
- 맛슐랭 (taste_agent)
- 영양사 (nutrition_agent)
- 예산 관리자 (budget_agent)
- 일정 관리자 (scheduler_agent)
- 요리사 (chef_agent)
- 코디네이터 (coordinator_agent)

**프로세스:**
1. 맛슐랭: 선호도 분석 및 메뉴 검색
2. 영양사: 영양 균형 평가
3. 예산 관리자: 가성비 분석
4. 일정 관리자: 시간 제약 고려
5. 요리사: 집밥 레시피 추가
6. 코디네이터: 최종 1안, 2안 선정

---

### 2. RECIPE_ONLY (레시피/조리법만)
**트리거:** "된장찌개 만드는 법", "파스타 레시피", "어떻게 만들어?"

**실행 에이전트:**
- 요리사 (chef_agent) **만**

**프로세스:**
1. 사용자가 요청한 요리 파악
2. 데이터베이스에서 레시피 검색 (`search_home_recipes`)
3. 없으면 AI로 생성 (`generate_recipe_with_llm`)
4. 상세 레시피 제공:
   - 재료 목록 (정확한 양)
   - 단계별 조리 순서
   - 조리 시간 및 난이도
   - 요리 팁

**장점:**
- ⚡ 빠른 응답 (1개 에이전트만 실행)
- 🎯 정확한 조리법 제공
- 💰 API 비용 절감

---

### 3. BUDGET_CHECK (예산 확인)
**트리거:** "이번 달 식비 얼마 썼어?", "예산 남았어?"

**실행 에이전트:**
- 예산 관리자 (budget_agent) **만**

---

### 4. NUTRITION_INFO (영양 정보)
**트리거:** "칼로리 얼마야?", "영양 분석"

**실행 에이전트:**
- 영양사 (nutrition_agent) **만**

---

### 5. SCHEDULE_CHECK (일정 확인)
**트리거:** "오늘 일정 어때?", "언제 식사 가능해?"

**실행 에이전트:**
- 일정 관리자 (scheduler_agent) **만**

---

### 6. QUICK_MEAL (빠른 식사)
**트리거:** "30분 안에", "빨리 먹을 수 있는"

**실행 에이전트:**
- 일정 관리자 (scheduler_agent)
- 맛슐랭 (taste_agent)

---

## 💬 대화 맥락 관리

### 구현 방식

**`crew.py`:**
```python
# 대화 히스토리 저장
self.conversation_history = []

# 실행 후 업데이트
self.conversation_history.append(f"사용자: {user_request}")
self.conversation_history.append(f"시스템: {result[:200]}...")
```

**의도 분석 시 활용:**
```python
history_str = "\n".join(self.conversation_history[-3:])  # 최근 3개만
```

### 예시

**대화 1:**
```
사용자: 오늘 저녁 메뉴 추천해줘
시스템: [전체 에이전트 실행] → 된장찌개 추천
```

**대화 2:**
```
사용자: 그거 만드는 법 알려줘
오케스트레이터: "그거" = 이전 대화의 "된장찌개" → RECIPE_ONLY
시스템: [요리사만 실행] → 된장찌개 레시피 제공
```

**대화 3:**
```
사용자: 다른 레시피도 알려줘
오케스트레이터: 맥락상 레시피 요청 → RECIPE_ONLY
시스템: [요리사만 실행] → 추천 레시피 제공
```

---

## 🚀 사용 예시

### 예시 1: 레시피 질문

**입력:**
```
된장찌개 만드는 법 알려줘
```

**시스템 동작:**
```
[1단계] 오케스트레이터 의도 분석
  → workflow_type: RECIPE_ONLY
  → required_agents: ["chef_agent"]

[2단계] 요리사 에이전트만 태스크 생성
  → Task: 된장찌개 레시피 생성

[3단계] 요리사 에이전트 실행
  → AI 레시피 생성 도구 사용
  → 상세 레시피 반환
```

**출력:**
```
🍳 AI 생성 레시피

## 된장찌개
구수하고 깊은 맛의 전통 한식

## 난이도 및 시간
- 난이도: 쉬움
- 조리 시간: 30분
- 칼로리: 350kcal

## 재료 (2인분 기준)
- 된장: 2큰술
- 두부: 1/2모
- 애호박: 1/2개
- 감자: 1개
...

## 조리 순서
1. 멸치와 다시마로 육수를 낸다 (10분)
2. 감자와 애호박을 썬다
3. 끓는 육수에 된장을 푼다
...

## 요리 팁
- 된장은 체에 거르면 더 부드럽습니다
- 두부는 마지막에 넣어 모양이 흐트러지지 않게 하세요
```

**비교 (기존 시스템):**
- ❌ 모든 에이전트 실행 (6개)
- ❌ 영양사가 식단 기록 조회 → 에러
- ❌ 예산 관리자가 예산 조회 → 불필요
- ❌ 느린 응답, 높은 비용

**새 시스템:**
- ✅ 요리사만 실행 (1개)
- ✅ 빠른 응답
- ✅ 정확한 레시피
- ✅ 비용 절감

---

### 예시 2: 대화 맥락 활용

**대화 흐름:**

```
[질문 1]
사용자: 오늘 저녁 메뉴 추천해줘
시스템: (FULL_RECOMMENDATION) → 된장찌개 추천

[질문 2]
사용자: 그거 레시피 알려줘
오케스트레이터:
  - 대화 맥락: "된장찌개 추천"
  - "그거" = 된장찌개
  - workflow_type: RECIPE_ONLY
시스템: (RECIPE_ONLY) → 된장찌개 레시피

[질문 3]
사용자: 더 쉬운 거 없어?
오케스트레이터:
  - 대화 맥락: "레시피" 관련
  - 난이도 쉬운 레시피 요청
  - workflow_type: RECIPE_ONLY
시스템: (RECIPE_ONLY) → 쉬운 레시피 추천
```

---

## 🎨 프론트엔드 개선 (app.py)

### 변경 사항

**1. 동적 진행 표시**
```python
progress_placeholder.info("🎛️ 1단계: 사용자 의도 분석 중...")
progress_placeholder.info("🔧 2단계: 필요한 에이전트 선택 중...")
progress_placeholder.info("⚙️ 3단계: 에이전트 실행 중...")
```

**2. 대화 맥락 유지**
- Streamlit session_state에 crew 저장
- 세션 전체에서 대화 히스토리 유지

**3. 워크플로우 정보 표시**
```python
st.success(f"✅ 완료! (대화 기록: {len(history)}개)")
```

---

## 🔧 기술적 세부사항

### JSON 파싱 전략

오케스트레이터의 응답을 안전하게 파싱:

```python
# JSON 추출
if "```json" in result_str:
    result_str = result_str.split("```json")[1].split("```")[0]

# 중괄호 찾기
start_idx = result_str.find('{')
end_idx = result_str.rfind('}')
json_str = result_str[start_idx:end_idx+1]

# 파싱
intent = json.loads(json_str)
```

### 에러 처리

파싱 실패 시 기본값 반환:
```python
except Exception as e:
    return {
        "workflow_type": "FULL_RECOMMENDATION",
        "required_agents": [...],
        "reasoning": f"파싱 실패: {e}"
    }
```

---

## 📈 성능 개선

### 응답 속도

| 워크플로우 | 에이전트 수 | 예상 시간 |
|-----------|-----------|----------|
| RECIPE_ONLY | 1개 | ~10초 |
| BUDGET_CHECK | 1개 | ~5초 |
| QUICK_MEAL | 2개 | ~15초 |
| FULL_RECOMMENDATION | 6개 | ~40초 |

### API 비용 절감

- 레시피 질문: **83% 절감** (6개 → 1개 에이전트)
- 예산/일정 확인: **83% 절감**
- 평균: **약 50% 절감**

---

## 🧪 테스트 시나리오

### 시나리오 1: 레시피 요청
```bash
python crew.py
# 입력: 된장찌개 만드는 법 알려줘
# 예상: RECIPE_ONLY, 요리사만 실행
```

### 시나리오 2: 전체 추천
```bash
python crew.py
# 입력: 오늘 저녁 메뉴 추천해줘
# 예상: FULL_RECOMMENDATION, 모든 에이전트 실행
```

### 시나리오 3: 대화 맥락
```bash
streamlit run app.py
# 1. "오늘 저녁 메뉴 추천해줘"
# 2. "그거 레시피 알려줘" ← 맥락 인식 확인
```

---

## 🎯 핵심 이점

### 1. 효율성 ⚡
- 필요한 에이전트만 실행
- 빠른 응답 속도
- API 비용 절감

### 2. 정확성 🎯
- 사용자 의도 정확히 파악
- 적절한 에이전트 선택
- 불필요한 작업 제거

### 3. 유연성 🔄
- 대화 맥락 이해
- 후속 질문 처리
- 다양한 질문 타입 지원

### 4. 확장성 📈
- 새로운 워크플로우 쉽게 추가
- 에이전트 카드 시스템으로 관리
- 독립적인 컴포넌트 설계

---

## 🚀 향후 개선 방향

### 1. 워크플로우 추가
- `COMPARISON`: 메뉴 비교
- `HEALTH_ANALYSIS`: 건강 분석
- `RECIPE_VARIATION`: 레시피 변형

### 2. 학습 기능
- 사용자 패턴 학습
- 자주 사용하는 워크플로우 최적화
- 개인화된 응답

### 3. 병렬 처리
- 독립적인 에이전트 병렬 실행
- 응답 속도 추가 향상

### 4. 캐싱
- 자주 요청되는 레시피 캐싱
- 중복 API 호출 방지

---

## 📝 결론

동적 워크플로우 시스템으로 다음을 달성했습니다:

✅ **문제 해결**: "된장찌개 레시피 알려줘" → 불필요한 에이전트 실행 제거
✅ **효율성**: 평균 50% API 비용 절감, 빠른 응답
✅ **유연성**: 대화 맥락 이해, 다양한 질문 타입 지원
✅ **확장성**: 새로운 워크플로우 쉽게 추가 가능

**핵심은 오케스트레이터가 매번 사용자 의도를 분석하여 필요한 에이전트만 동원하는 것입니다!**

---

## 📚 관련 파일

- `agent_cards.py`: 에이전트 메타데이터
- `agents/orchestrator_agent.py`: 오케스트레이터
- `tools/orchestrator_tools.py`: 의도 분석 도구
- `crew.py`: 동적 워크플로우 매니저
- `app.py`: Streamlit UI

---

**작성일**: 2025-10-25
**버전**: 2.0
**작성자**: AI Crew System

